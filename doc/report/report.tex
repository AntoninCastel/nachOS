\documentclass{report}

\usepackage[a4paper, total={6in, 9.5in}]{geometry}
\usepackage{listings}
\usepackage{indentfirst}
\usepackage[utf8]{inputenc}
\newcommand{\myparagraph}[1]{\paragraph*{#1}\mbox{}\\}

\title{Rapport NachOS}
\author{Antonin Castel \and
		Cyprien Eymond Laritaz \and
		Marianne Garnier \and
		Robin Blanc}

\begin{document}
\maketitle

\section*{Fonctionnalités}
Notre implémentation de NachOS permet de lancer des programmes écrits en C permettant des entrées et sorties ainsi que de la programmation avec plusieurs threads. Les fonctions d'entrées et sorties sont thread-safes et peuvent être utilisées sans effort côté utilisateur.

\section*{Spécifications}
\subsection*{Terminaison}
\myparagraph{Exit}

\textsc{Synopsis}\\
	\texttt{void Exit(int code)}\\
	
\textsc{Description}\\
	Permet de terminer le programme utilisateur en renvoyant le code d'erreur \texttt{code}\\
	
\textsc{Notes}\\
	Dans le cas où cette fonction est appelée par le thread "main" du processus principal, elle consiste en un appel à \texttt{Halt} précédé d'une récupération du code d'erreur afin de faire retourner ce code par le programme. Si \texttt{code} = 0, alors le programme s'est terminé sans erreur.
		
\myparagraph{Halt}

\textsc{Synopsis}\\
	\texttt{void Halt()}\\
	
\textsc{Description}\\
	Permet d'arrêter la machine.\\

\subsection*{Entrées/sorties}
\myparagraph{PutChar}

\textsc{Synopsis}\\
	\texttt{void PutChar(char c)}\\
	
\textsc{Description}\\
	Permet d'imprimer sur la sortie standard le caractère codé par le paramètre \texttt{c}.\\
	
\textsc{Notes}\\
	Lorsque le caractère passé en paramètre est \texttt{EOF}, le caractère n'est pas imprimé. Dans tous les autres cas, il l'est.




\myparagraph{PutString}

\textsc{Synopsis}\\
	\texttt{void PutString(char *string)}\\
	
\textsc{Description}\\
	Permet d'imprimer la chaîne de caractères \texttt{string} passée en paramètre.\\
	
\textsc{Notes}\\
	La longueur de la chaine ne peut être supérieure à 200 caractères.


\myparagraph{GetChar}

\textsc{Synopsis}\\
	\texttt{char GetChar()}\\
	
\textsc{Description}\\
	Permet de récupérer un caractère sur l'entrée standard.\\
	
\textsc{Valeur de retour}\\
	Un \texttt{char} correspondant au caractère lu sur l'entrée standard.\\
	
\textsc{Notes}\\
	Cette fonction est bloquante tant qu'il n'y a pas de caractère à lire sur l'entrée standard.
	



\myparagraph{GetString}

\textsc{Synopsis}\\
	\texttt{void GetString(char *string, int len)}\\
	
\textsc{Description}\\
	Permet de récupérer jusqu'à \texttt{len} caractères de l'entrée standard afin de les stocker dans la chaine de caractères \texttt{string}.\\
	
\textsc{Notes}\\
	Lorsque \texttt{EOF} est lu sur l'entrée standard, la lecture s'arrête même si moins de \texttt{n} caractères ont été lus.\\
	Le nombre maximum de caractères pouvant être lus est 200.\\
	
	
	
	
\myparagraph{PutInt}

\textsc{Synopsis}\\
	\texttt{void PutInt(int n)}\\
	
\textsc{Description}\\
	Permet d'imprimer sur la sortie standard la valeur de l'entier \texttt{n} passé en paramètre.\\
	

\myparagraph{GetInt}

\textsc{Synopsis}\\
	\texttt{void GetInt(int *n)}\\
	
\textsc{Description}\\
	Permet de récupérer un entier sur l'entrée standard et le stocker dans la variable pointée par \texttt{n} passée en paramètre.\\
	
\textsc{Notes}\\
	Cette fonction est bloquante tant qu'il n'y a pas d'entier à lire sur l'entrée standard.
	

\subsection*{Multithreading}
\myparagraph{UserThreadCreate}

\textsc{Synopsis}\\
	\texttt{int UserThreadCreate(void f(void *arg), void *arg)}\\
	
\textsc{Description}\\
	Permet de créer un nouveau thread utilisateur qui va exécuter la fonction \texttt{f} avec son argument \texttt{arg}. \texttt{f} et \texttt{arg} sont donnés en paramètre de la fonction.\\
	
\textsc{Valeur de retour}\\
	Un entier qui correspond à l'identifiant du thread créé ou -1 en cas d'erreur.\\
	
\textsc{Notes}\\
	Un appel de la fonction \texttt{UserThreadExit} est nécessaire à la fin de la fonction \texttt{f} afin de terminer correctement le thread. Sans cet appel, le comportement correct du programme n'est pas garanti.\\
	Il est possible de lancer 50 threads par processus.
	
	
	
	
	
\myparagraph{UserThreadExit}

\textsc{Synopsis}\\
	\texttt{void UserThreadExit()}\\
	
\textsc{Description}\\
	Permet de quitter un thread correctement.\\
	
\textsc{Notes}\\
	Cette fonction doit toujours être appelée dans un chemin d’exécution d'une fonction appelée au moyen de l'appel système \texttt{UserThreadCreate}.
	
	
	
	
	
\myparagraph{UserThreadJoin}

\textsc{Synopsis}\\
	\texttt{void UserThreadJoin(int tid)}\\
	
\textsc{Description}\\
	Permet au thread courant d'attendre la fin de l'exécution du thread dont l'identifiant de thread est \texttt{tid} passé en paramètre.\\
	
\textsc{Notes}\\
	Si le thread avec pour numéro d'identification \texttt{tid} n'est pas terminé, la fonction est bloquante, jusqu'à ce que le thread termine. Si \texttt{tid} est supérieur ou égal à 50 provoque une erreur.\\
Seuls les threads se terminant par l'appel à \texttt{UserThreadExit} peuvent être attendus avec un \texttt{UserThreadJoin}. Le comportement n'est pas garanti si cette condition n'est pas respectée.


\myparagraph{Sem\_Init}
	
	\textsc{Synopsis}\\
		\texttt{semaphore Sem\_Init(int n)}\\

\textsc{Description}\\
	Permet d'initialiser un sémaphore avec \texttt{n} unités disponibles.\\
	
\textsc{Valeur de retour}\\
	Un identifiant de sémaphore (int), -1 en cas d'erreur.\\

\textsc{Notes}\\
	Les identifiants de sémaphores sont uniques dans la session en cours. Le nombre maximal de sémaphores créées par session est fixé à 20.\\
	
\myparagraph{Sem\_P}\\
\textsc{Synopsis}\\	
	\texttt{int Sem\P(semaphore s)}\\

\textsc{Description}\\
	Permet de prendre une unité sur le sémaphore dont l'identifiant \texttt{s} est passé en paramètre.\\
	
\textsc{Valeur de retour}\\
0 si la fonction se déroule normalement, -1 en cas d'erreur.\\

\myparagraph{Sem\_V}\\
\textsc{Synopsis}\\	

\texttt{int Sem\_V(semaphore s)}\\

\textsc{Description}\\
	Permet de rajouter une unité sur le sémaphore dont l'identifiant \texttt{s} est passé en paramètre.\\
	
\textsc{Valeur de retour}\\
0 si la fonction se déroule normalement, -1 en cas d'erreur.\\

\myparagraph{Sem\_GetValue}\\
\textsc{Synopsis}\\	
	\texttt{int Sem\_GetValue(semaphore s)}\\

\textsc{Description}\\
	Permet d'obtenir le nombre d'unité du sémaphore dont l'identifiant \texttt{s} est donné en paramètre.\\
	
\textsc{Valeur de retour}\\
Le nombre d'unité du sémaphore \texttt{s}, -1 en cas d'erreur.\\

\myparagraph{Sem\_Destroy}\\
\textsc{Synopsis}\\	
	\texttt{int Sem\_Destroy(semaphore s)}\\

\textsc{Description}\\
	Permet de libérer le sémaphore dont l'identifiant \texttt{s} est passé en paramètre.\\

\textsc{Valeur de retour}\\
0 si la fonction se déroule normalement, -1 en cas d'erreur.\\
	
\textsc{Note}\\
	Les fonctions \texttt{Sem\_P}, \texttt{Sem\_V} ou \texttt{Sem\_GetValue} renverront une erreur après destruction de \texttt{s}.\\
	








	
	

\section*{Tests utilisateurs}
\subsection*{Entrées/sorties}
Nous avons réalisé des programmes de tests qui
\begin{itemize}
 \item Lit un caractère sur l'entrée standard et l'imprime sur la sortie standard
 \item Lit un entier sur l'entrée standard et l'imprime sur la sortie standard
 \item Lit une chaine de caractères sur l'entrée standard et l'imprime sur la sortie
 standard
 \item Imprime les entiers -2147483648 et 2147483647 sur la sortie standard.
\end{itemize}
Le script \texttt{nachos-step1} teste toutes les fonctionnalités implémentées dans l'étape 1, soit les appels systèmes \texttt{PutChar}, \texttt{PutInt}, \texttt{GetChar}, \texttt{GetInt}, \texttt{PutString} et \texttt{GetString}.
Les tests effectués sont des cas de
\begin{itemize}
 \item \textbf{Bonne utilisation des appels systèmes}: permet de constater que les appels systèmes, lorsqu'ils sont appelés correctement, fonctionnent. Des caractères spéciaux, des chiffres correspondant aux bornes limites, négatifs, positifs sont testés pour vérifier que l'implémentation colle à la spécification.
 \item \textbf{Dépassement du nombre de caractères maximum à lire}: permet de connaître le type de problème qui peut survenir lorsque la fonction n'est pas utilisée correctement par l'utilisateur. Cela permet de rendre plus robuste les appels systèmes.
 \item \textbf{Dépassement de capacité des entiers}: Pareil que pour le type de test précédent, nous a permet de détecter le comportement lorsqu'un entier trop grand est soumis à la lecture ou à l'écriture.
\end{itemize}
Les tests effectués nous ont permis de détecter une erreur sur \texttt{GetInt}, confirmé par le test sur \texttt{PutInt}. \texttt{GetInt} Peut correctement lire les entiers de -2147417856 à 2147483647 (au lieu de -2147483648 à 2147483647).

\section*{Implémentation}


\section*{Organisation du travail}
Le travail s'organise le plus souvent avec deux machines. Ces deux machines permettent à tout le groupe d'avancer dans la programmation d'une fonctionnalité et de faire de la recherche d'autre part (prototype exact, fichiers à inclure etc...). La machine où se fait le développement et le débuggage est souvent branchée à un second écran plus grand afin que tout le groupe puisse voir clairement le code ou les étapes de débuggage.\\

Dépendamment de l'étape dans laquelle nous nous trouvons, nous augmentons le nombre de machines afin d'avoir une capacité de lecture/compréhension du code existant plus grande avec une personne du groupe par machine.\\

Le groupe alterne les phases de discussions/débats dans le but de dégager les différents problèmes ou implications de chaque fonctionnalités à développer. Cette étape permet d'orienter la réflexion du groupe vers la même direction ainsi que d'harmoniser les connaissances de chacun et de lever des doutes et clarifier des concepts du cours ou de NachOS que tout le monde n'a pas forcément assimilé de la même façon.\\

Le travail est collectif et n'est pas systématiquement réparti fonctionnalité par fonctionnalité à certains membres du groupe. Il arrive qu'un membre du groupe s'approprie une tâche, mais les autres membres lui apportent de l'aide, que ça soit directement en debuggant le code, ou par le biais d'idées et de discussion à propos de la fonctionnalité. C'est le cas des fonctionnalités plus petites, comme certains appels systèmes d'entrées/sorties.

\end{document}